<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PocketChimes</title>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-3G2QH25N85"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-3G2QH25N85');
  </script>

  <!-- PWA & theme color -->
  <meta name="theme-color" content="#111827" />

  <!-- Tab favicons (desktop/mobile) -->
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon_32_transparent.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon_16_transparent.png">
  <link rel="shortcut icon" href="/favicons/favicon_32_transparent.png" type="image/png">
  <link rel="apple-touch-icon" href="https://pocketchimes.com/favicons/favicon_180_transparent.png">
  <link rel="manifest" href="/favicons/site.webmanifest">

  <style>
    html, body {
      width: 100%;
      height: calc(var(--vh, 1vh) * 100);
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #111827;
      --text: #f9fafb;
      --shadow-soft: 0 12px 30px rgba(0, 0, 0, 0.35);
      --radius-full: 999px;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;

      --ui-white: rgba(248, 250, 252, 0.95);
      --ui-white-dim: rgba(248, 250, 252, 0.70);

      --slider-stroke: rgba(248, 250, 252, 0.16);

      --thumb-silver-1: rgba(248, 250, 252, 0.98);
      --thumb-silver-2: rgba(203, 213, 225, 0.98);
      --thumb-silver-3: rgba(148, 163, 184, 0.98);
      --thumb-stroke: rgba(2, 6, 23, 0.40);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font-main);
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text);
      min-height: calc(var(--vh, 1vh) * 100);
      display: flex;
      align-items: stretch;
      justify-content: center;
      position: relative;
    }

    .global-logo {
      position: fixed;
      top: 1.1rem;
      left: 50%;
      transform: translateX(-50%);
      width: 96px;
      height: auto;
      z-index: 20;
      pointer-events: none;
    }

    .app {
      width: 100%;
      max-width: 480px;
      margin: auto;
      padding: 3rem 1.2rem 2.5rem;
    }

    .card,
    .note-card {
      background: radial-gradient(circle at top left, #1f2937 0, #020617 70%);
      border-radius: 1.75rem;
      border: 1px solid #020617;
      box-shadow: var(--shadow-soft);
      padding: 1.4rem 1.5rem 1.6rem;
      backdrop-filter: blur(16px);
      text-align: center;
    }

    .title {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      margin-bottom: 0.4rem;
    }

    .subtitle {
      font-size: 0.9rem;
      opacity: 0.82;
      line-height: 1.4;
      margin-bottom: 1.2rem;
    }

    .primary-btn {
      border-radius: var(--radius-full);
      border: none;
      padding: 0.7rem 1.1rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: #facc15;
      color: #1f2937;
      box-shadow: 0 10px 24px rgba(0,0,0,0.45);
    }

    .primary-btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 5px 12px rgba(0,0,0,0.55);
    }

    .note-title {
      font-size: 1.15rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
    }

    .note-subtitle {
      font-size: 0.85rem;
      opacity: 0.8;
      margin-bottom: 0.7rem;
    }

    .note-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 0.65rem;
      margin-top: 0.4rem;
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 0.2rem;
    }

    .note-btn {
      border: none;
      border-radius: 1rem;
      padding: 0.6rem 0.3rem;
      font-weight: 700;
      font-size: 0.9rem;
      color: #0b1120;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
      transition: transform 0.16s ease-out, box-shadow 0.16s ease-out, filter 0.16s ease-out;
      text-shadow: 0 1px 3px rgba(0,0,0,0.35);
    }

    .note-btn:active {
      transform: translateY(2px) scale(0.97);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.55);
      filter: brightness(0.95);
    }

    .note-btn.disabled {
      opacity: 0.45;
      filter: grayscale(0.35);
      cursor: not-allowed;
      transform: none !important;
    }

    .note-help {
      margin-top: 0.8rem;
      font-size: 0.8rem;
      opacity: 0.82;
    }

    .play-screen {
      position: fixed;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: #020617;
      padding: 1.2rem;
      padding-bottom: calc(1.2rem + 110px);
      background: #111827;
    }

    .play-screen.active { display: flex; }

    /* Shared top button style */
    .top-btn {
      position: fixed;
      top: 0.9rem;
      border-radius: var(--radius-full);
      border: 1px solid rgba(15, 23, 42, 0.4);
      background: rgba(248, 250, 252, 0.92);
      padding: 0.35rem 0.85rem;
      font-size: 0.8rem;
      font-weight: 800;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.3);
      z-index: 60;
      line-height: 1;
      white-space: nowrap;
    }
    .top-btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 4px 8px rgba(15, 23, 42, 0.45);
    }

    .back-btn { left: 0.9rem; }
    .add-mode-back { left: 0.9rem; z-index: 70; display:none; }
    .add-mode-back.active { display:inline-flex; }

    .top-right-stack {
      position: fixed;
      top: 0.9rem;
      right: 0.9rem;
      z-index: 60;
      display: none;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.35rem;
    }
    .top-right-stack.active { display: flex; }

    .stack-btn {
      position: static;
      right: auto;
      top: auto;
      padding: 0.35rem 0.85rem;
      min-width: 0;
    }

    /* --- Dual layout (remove the "tile" look) --- */
    .dual-area {
      width: 100%;
      max-width: 520px;
      display: flex;
      align-items: stretch;
      justify-content: center;
      gap: 0;
      margin-top: 0.2rem;
      margin-bottom: 0.95rem;
      box-shadow: none;
      border-radius: 0;
      overflow: visible;
      background: transparent;
    }

    .dual-pane {
      flex: 1;
      padding: 0.8rem 0.8rem 0.6rem;
      display: grid;
      grid-template-rows: var(--label-slot, 4.9rem) 170px auto;
      align-items: center;
      justify-items: center;
      min-height: 320px;
    }

    .dual-pane.hidden { display: none; }

    .note-slot {
      width: 100%;
      min-height: var(--label-slot, 4.9rem);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 0.55rem;
    }

    .play-note-label {
      font-size: 3.2rem;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.22);
      cursor: pointer;
      user-select: none;
      line-height: 1.05;
    }

    .bell-visual {
      position: relative;
      width: 150px;
      height: 150px;
      margin: 0;
      cursor: pointer;
    }

    .bell-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 8px solid rgba(15, 23, 42, 0.85);
      background: radial-gradient(circle at 30% 20%,
        rgba(248,250,252,0.96) 0,
        rgba(248,250,252,0.7) 40%,
        rgba(248,250,252,0.25) 100%);
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.45);
      transform-origin: 50% 15%;
      transform: translate(0px, 0px) rotate(0deg);
      transition: transform 0.09s ease-out;
    }

    .bell-clapper {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(15, 23, 42, 0.95);
      box-shadow: 0 5px 10px rgba(15,23,42,0.7);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .hint-text {
      font-size: 0.85rem;
      opacity: 0.9;
      max-width: 18rem;
      line-height: 1.5;
      margin-bottom: 0.8rem;
      color: rgba(2,6,23,0.92);
      text-shadow: 0 1px 0 rgba(255,255,255,0.22);
    }

    /* --- Calibration toast --- */
    .calib-toast {
      position: fixed;
      left: 50%;
      top: 18%;
      transform: translateX(-50%);
      width: min(520px, 92vw);
      background: rgba(248, 250, 252, 0.92);
      color: rgba(2,6,23,0.92);
      border-radius: 1.25rem;
      border: 1px solid rgba(2,6,23,0.18);
      box-shadow: 0 16px 42px rgba(0,0,0,0.25);
      padding: 0.85rem 1.0rem;
      z-index: 75;
      display: none;
      text-align: center;
    }
    .calib-toast.active { display: block; }

    .calib-toprow {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.55rem;
      margin-bottom: 0.25rem;
    }

    .calib-title {
      font-weight: 1000;
      letter-spacing: 0.02em;
    }

    .calib-info-btn {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(2,6,23,0.22);
      background: rgba(248,250,252,0.98);
      color: rgba(2,6,23,0.92);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 1000;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(15,23,42,0.16);
      line-height: 1;
      user-select: none;
    }
    .calib-info-btn:active { transform: translateY(1px) scale(0.98); }

    .calib-sub {
      font-size: 0.86rem;
      opacity: 0.90;
      line-height: 1.35;
    }

    .calib-skip {
      margin-top: 0.55rem;
      display: none;
      justify-content: center;
    }
    .calib-skip.active { display: flex; }

    .calib-skip-btn {
      border-radius: 999px;
      border: 1px solid rgba(2,6,23,0.20);
      background: rgba(248, 250, 252, 0.96);
      padding: 0.45rem 0.85rem;
      font-size: 0.80rem;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 10px 18px rgba(0,0,0,0.14);
    }
    .calib-skip-btn:active { transform: translateY(1px) scale(0.98); }

    /* --- sliders --- */
    input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      outline: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    input[type="range"]::-webkit-slider-runnable-track{
      height: 10px;
      border-radius: 999px;
      background: #000;
      box-shadow:
        inset 0 0 0 1px var(--slider-stroke),
        0 10px 22px rgba(0,0,0,0.18);
    }

    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 25%,
        var(--thumb-silver-1) 0%,
        var(--thumb-silver-2) 45%,
        var(--thumb-silver-3) 100%);
      border: 1px solid var(--thumb-stroke);
      box-shadow:
        0 12px 26px rgba(0,0,0,0.22),
        inset 0 0 0 1px rgba(248,250,252,0.25);
      margin-top: -6px;
    }

    input[type="range"]::-moz-range-track{
      height: 10px;
      border-radius: 999px;
      background: #000;
      box-shadow:
        inset 0 0 0 1px var(--slider-stroke),
        0 10px 22px rgba(0,0,0,0.18);
    }

    input[type="range"]::-moz-range-thumb{
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 25%,
        var(--thumb-silver-1) 0%,
        var(--thumb-silver-2) 45%,
        var(--thumb-silver-3) 100%);
      border: 1px solid var(--thumb-stroke);
      box-shadow:
        0 12px 26px rgba(0,0,0,0.22),
        inset 0 0 0 1px rgba(248,250,252,0.25);
    }

    .sustain-control {
      position: fixed;
      bottom: calc(14px + env(safe-area-inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      width: min(360px, 90vw);
      display: none;
      flex-direction: column;
      gap: 0.35rem;
      z-index: 60;
      pointer-events: auto;
      align-items: center;
    }
    .sustain-control.active { display: flex; }

    .sustain-header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--ui-white);
      text-shadow: 0 2px 8px rgba(2,6,23,0.45);
      font-weight: 900;
      letter-spacing: 0.02em;
    }

    .sustain-title { font-size: 0.88rem; opacity: 0.95; }
    .sustain-value {
      font-size: 0.88rem;
      font-weight: 900;
      opacity: 0.95;
      min-width: 2.2rem;
      text-align: right;
    }

    .sustain-slider { width: 100%; height: 44px; }

    .sustain-hint {
      font-size: 0.72rem;
      color: var(--ui-white-dim);
      text-shadow: 0 2px 8px rgba(2,6,23,0.45);
      margin-top: -0.10rem;
      text-align: center;
      width: 100%;
      opacity: 0.92;
    }

    @media (orientation: landscape) {
      .global-logo { top: 0.6rem; width: 78px; }
      .play-note-label { font-size: 2.6rem; }
      .hint-text { margin-bottom: 0.4rem; }
      .play-screen { padding-bottom: calc(1.2rem + 96px); }
      .dual-pane { min-height: 240px; grid-template-rows: 4.2rem 160px auto; }
    }

    @media (max-width: 400px) {
      .card, .note-card { padding: 1.2rem 1.2rem 1.3rem; }
      .note-btn { padding: 0.55rem 0.25rem; }
      .sustain-control { width: min(340px, 92vw); }
      .play-screen { padding-bottom: calc(1.2rem + 106px); }
      .dual-pane { min-height: 300px; }
    }
  </style>
</head>

<body>
  <img class="global-logo" src="/favicons/favicon_512_transparent.png" alt="PocketChimes bell logo" />

  <div class="app" id="motion-screen" role="main">
    <div class="card">
      <div class="title">PocketChimes</div>
      <p class="subtitle">
        This app uses your phone’s motion sensors so you can swing it like a handbell.
        On iPhone, you’ll be asked to allow motion access.
      </p>
      <button class="primary-btn" id="start-btn" type="button">Enable Motion & Start</button>
    </div>
  </div>

  <button class="top-btn add-mode-back" id="add-mode-back" type="button">← Back</button>

  <div class="app" id="note-screen" style="display:none;" role="main">
    <div class="note-card">
      <div class="note-title" id="note-title">Choose your note</div>
      <div class="note-subtitle" id="note-subtitle">
        Full chromatic C5–B7 (top note B7). Each note uses the bell color palette.
      </div>
      <div class="note-grid" id="note-grid"></div>
      <div class="note-help" id="note-help">Swing to ring. You’ll see your note and bell on the next screen.</div>
    </div>
  </div>

  <div class="sustain-control" id="sustain-wrapper" aria-label="Damping control">
    <div class="sustain-header">
      <span class="sustain-title">Damping</span>
      <span class="sustain-value" id="sustain-value-label">5</span>
    </div>
    <input
      type="range"
      id="sustain-slider"
      class="sustain-slider"
      min="1"
      max="10"
      step="1"
      value="5"
      aria-label="Damping slider"
    />
    <div class="sustain-hint">10 = Least Damped · 1 = Most Damped</div>
  </div>

  <div class="play-screen" id="play-screen" role="main">
    <button class="top-btn back-btn" id="back-btn" type="button">← Notes</button>

    <div class="top-right-stack" id="top-right-stack">
      <button class="top-btn stack-btn" id="add-bell-btn" type="button">Add Bell</button>
      <button class="top-btn stack-btn" id="change-2nd-btn" type="button" style="display:none;">Change 2nd Bell</button>
      <button class="top-btn stack-btn" id="remove-bell-btn" type="button" style="display:none;">Remove Bell</button>
    </div>

    <div class="calib-toast" id="calib-toast" aria-live="polite">
      <div class="calib-toprow">
        <div class="calib-title">Calibrate Forward Ring</div>
        <div class="calib-info-btn" id="calib-info-btn" role="button" aria-label="Info">i</div>
      </div>
      <div class="calib-sub">
        Ring the phone <b>Away From You</b> 3 times. (Hold it the same way you’ll play.)
        <br/>Progress: <span id="calib-progress">0</span>/3
      </div>
      <div class="calib-skip" id="calib-skip-wrap">
        <button class="calib-skip-btn" id="calib-skip-btn" type="button">Skip Calibration</button>
      </div>
    </div>

    <div class="dual-area" id="dual-area" aria-label="Bell area">
      <div class="dual-pane" id="pane-left">
        <div class="note-slot">
          <div class="play-note-label" id="play-note-label-left">C5</div>
        </div>

        <div class="bell-visual" id="bell-visual-left" role="button" aria-label="Tap to ring left bell" tabindex="0">
          <div class="bell-ring" id="bell-ring-left"></div>
          <div class="bell-clapper"></div>
        </div>

        <div style="height: 10px;"></div>
      </div>

      <div class="dual-pane hidden" id="pane-right">
        <div class="note-slot">
          <div class="play-note-label" id="play-note-label-right">D5</div>
        </div>

        <div class="bell-visual" id="bell-visual-right" role="button" aria-label="Tap to ring right bell" tabindex="0">
          <div class="bell-ring" id="bell-ring-right"></div>
          <div class="bell-clapper"></div>
        </div>

        <div style="height: 10px;"></div>
      </div>
    </div>

    <div class="hint-text">
      Swing your phone like a handbell.
      Tap the note or bell if needed.
    </div>
  </div>

  <script>
    function setVhUnit() {
      document.documentElement.style.setProperty("--vh", `${window.innerHeight * 0.01}px`);
    }
    setVhUnit();
    window.addEventListener("resize", setVhUnit);
    window.addEventListener("orientationchange", () => {
      setTimeout(setVhUnit, 50);
      setTimeout(setVhUnit, 250);
    });

    // ----- SCREEN WAKE LOCK -----
    let wakeLock = null;
    const wakeLockSupported = "wakeLock" in navigator;

    async function requestWakeLock() {
      if (!wakeLockSupported) return;
      try {
        wakeLock = await navigator.wakeLock.request("screen");
        wakeLock.addEventListener("release", () => { wakeLock = null; });
      } catch (err) {
        console.warn("Wake lock error:", err.name, err.message);
      }
    }

    function ensureWakeLock() {
      if (!wakeLockSupported) return;
      if (!wakeLock) requestWakeLock();
    }

    // ----- NOTE DEFINITIONS -----
    const PITCHES = [
      { name: "C",  color: "#FF3B30" },
      { name: "C#", color: "#FF2D92" },
      { name: "D",  color: "#FF9500" },
      { name: "D#", color: "#FFB300" },
      { name: "E",  color: "#FFEB3B" },
      { name: "F",  color: "#34C759" },
      { name: "F#", color: "#00FF7F" },
      { name: "G",  color: "#00C7BE" },
      { name: "G#", color: "#00B0FF" },
      { name: "A",  color: "#007AFF" },
      { name: "A#", color: "#AF52DE" },
      { name: "B",  color: "#5856D6" }
    ];

    const OCTAVES = [5, 6, 7];
    const NOTES = [];
    OCTAVES.forEach((oct) => {
      PITCHES.forEach((p) => {
        const id = `${p.name}${oct}`;
        const fileName = `${p.name}${oct}.wav`;
        const encodedFile = encodeURIComponent(fileName);

        let label;
        if (oct === 5) label = `${p.name} (Low)`;
        else if (oct === 6) label = p.name;
        else label = `${p.name} (High)`;

        NOTES.push({ id, label, file: `audio/${encodedFile}`, color: p.color });
      });
    });

    // ---- DOM ----
    const motionScreen  = document.getElementById("motion-screen");
    const noteScreen    = document.getElementById("note-screen");
    const playScreen    = document.getElementById("play-screen");

    const startBtn      = document.getElementById("start-btn");
    const noteGrid      = document.getElementById("note-grid");
    const backBtn       = document.getElementById("back-btn");

    const noteTitleEl   = document.getElementById("note-title");
    const noteSubEl     = document.getElementById("note-subtitle");
    const noteHelpEl    = document.getElementById("note-help");

    const topRightStack = document.getElementById("top-right-stack");
    const addBellBtn    = document.getElementById("add-bell-btn");
    const change2ndBtn  = document.getElementById("change-2nd-btn");
    const removeBellBtn = document.getElementById("remove-bell-btn");

    const addModeBack   = document.getElementById("add-mode-back");
    const paneRight     = document.getElementById("pane-right");

    const playNoteLeft  = document.getElementById("play-note-label-left");
    const playNoteRight = document.getElementById("play-note-label-right");

    const bellRingLeft  = document.getElementById("bell-ring-left");
    const bellRingRight = document.getElementById("bell-ring-right");

    const bellVisualLeft  = document.getElementById("bell-visual-left");
    const bellVisualRight = document.getElementById("bell-visual-right");

    const calibToast    = document.getElementById("calib-toast");
    const calibProgress = document.getElementById("calib-progress");
    const calibInfoBtn  = document.getElementById("calib-info-btn");
    const calibSkipWrap = document.getElementById("calib-skip-wrap");
    const calibSkipBtn  = document.getElementById("calib-skip-btn");

    const sustainWrapper    = document.getElementById("sustain-wrapper");
    const sustainSlider     = document.getElementById("sustain-slider");
    const sustainValueLabel = document.getElementById("sustain-value-label");

    // ---- AUDIO ----
    let audioCtx = null;
    let volumeMaxGain = 1.0;

    const noteBuffers = new Map();
    const noteBufferPromises = new Map();
    let preloadAllNotesPromise = null;

    function ensureAudioCtx() {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;
      if (!audioCtx || audioCtx.state === "closed") audioCtx = new AudioCtx();
    }

    async function resumeAudioCtx() {
      ensureAudioCtx();
      if (!audioCtx) return;
      if (audioCtx.state === "suspended") {
        try { await audioCtx.resume(); } catch (e) { console.warn("Audio resume error", e); }
      }
    }

    function resetAudioContextOnReturn() {
      if (audioCtx && audioCtx.state !== "closed") audioCtx.close().catch(() => {});
      audioCtx = null;
    }

    async function loadNoteBuffer(note) {
      if (noteBuffers.has(note.id)) return noteBuffers.get(note.id);
      if (noteBufferPromises.has(note.id)) return noteBufferPromises.get(note.id);

      ensureAudioCtx();
      if (!audioCtx) return null;

      const p = (async () => {
        const resp = await fetch(note.file, { cache: "force-cache" });
        if (!resp.ok) throw new Error(`Failed to fetch ${note.file}: ${resp.status}`);
        const arr = await resp.arrayBuffer();
        const buf = await audioCtx.decodeAudioData(arr);
        noteBuffers.set(note.id, buf);
        return buf;
      })().catch((e) => {
        console.warn("loadNoteBuffer error:", e);
        return null;
      }).finally(() => {
        noteBufferPromises.delete(note.id);
      });

      noteBufferPromises.set(note.id, p);
      return p;
    }

    function preloadAllNotes() {
      if (preloadAllNotesPromise) return preloadAllNotesPromise;

      const CONCURRENCY = 2;
      let idx = 0;
      let active = 0;
      let done = 0;

      preloadAllNotesPromise = new Promise((resolve) => {
        const pump = () => {
          while (active < CONCURRENCY && idx < NOTES.length) {
            const n = NOTES[idx++];
            active++;
            setTimeout(async () => {
              try { await loadNoteBuffer(n); } catch(e) {}
              active--;
              done++;
              if (done >= NOTES.length) resolve();
              else pump();
            }, 0);
          }
        };
        pump();
      }).then(() => console.log("All notes preloaded (progressive)"));

      return preloadAllNotesPromise;
    }

    function preloadNoteOnIntent(btn, note) {
      let started = false;
      const start = () => {
        if (started) return;
        started = true;
        loadNoteBuffer(note);
      };
      btn.addEventListener("touchstart", start, { passive: true });
      btn.addEventListener("mousedown", start);
      btn.addEventListener("pointerdown", start);
    }

    let headphoneWarningShown = false;
    function showHeadphoneWarningOnce() {
      if (headphoneWarningShown) return;
      headphoneWarningShown = true;
      alert(
        "Important: Please DO NOT use headphones when using this app — the bells can be EXTREMELY loud!\n" +
        "You're probably thinking to yourself, \"Oh it can't be *that* loud, can it?\"\n" +
        "Yes it can.\n\n" +
        "Also make sure your ringer isn't muted."
      );
    }

    // ---- SLIDERS ----
    sustainValueLabel.textContent = sustainSlider.value;
    sustainSlider.addEventListener("input", () => {
      sustainValueLabel.textContent = sustainSlider.value;
    });

    // ---- DAMPING-BASED SUSTAIN ----
    function dampingTimeConstantFromSlider(val) {
      const v = Math.max(1, Math.min(10, val));
      const t = (v - 1) / 9;
      const tcMin = 0.12;
      const tcMax = 4.2;
      return tcMin * Math.pow(tcMax / tcMin, t);
    }

    function applyDampingEnvelope(gainNode, now, sustainVal, peakGain) {
      const start = Math.max(peakGain, 0.0003);
      const floor = 0.00001;
      const tc = dampingTimeConstantFromSlider(sustainVal);

      try {
        if (typeof gainNode.gain.cancelAndHoldAtTime === "function") {
          gainNode.gain.cancelAndHoldAtTime(now);
        } else {
          gainNode.gain.cancelScheduledValues(now);
        }
      } catch (e) {}

      gainNode.gain.setValueAtTime(start, now);
      gainNode.gain.setTargetAtTime(floor, now, tc);

      return { floor, tc };
    }

    // ---- FACE-DOWN MUTE + CALIBRATION ----
    const activeRings = new Set();
    let faceDownTriggeredThisRingWindow = false;

    const FACE_DOWN_MAX_TILT_DEG = 30;
    const GRAVITY_MIN_MAG = 7.0;

    const TURN_MUTE_LOCKOUT_MS = 200;
    let lastBellPlayMs = 0;

    let faceDownZSign = null;
    let calibSamples = [];
    let calibUntilMs = 0;
    let calibLocked = false;
    let lastCalibG = null;

    const CALIB_WINDOW_MS = 1200;
    const CALIB_STILL_ACCEL_MAX = 0.45;
    const CALIB_MIN_SAMPLES = 16;
    const CALIB_NEAR_FLAT_COS = Math.cos((55 * Math.PI) / 180);
    const CALIB_GRAV_DELTA_MAX = 0.30;

    // Face-up latch (smooths big-swing misreads)
    let faceUpLatchedUntilMs = 0;
    const FACEUP_LATCH_HOLD_MS = 320;
    const FACEUP_ENTER_COS = -0.82;
    const FACEUP_EXIT_COS  = -0.60;
    let faceUpState = false;

    function getAccelMag(a) {
      if (!a) return Infinity;
      const ax = a.x || 0, ay = a.y || 0, az = a.z || 0;
      return Math.sqrt(ax*ax + ay*ay + az*az);
    }

    function beginFaceUpCalibration() {
      faceDownZSign = null;
      calibSamples = [];
      calibLocked = false;
      calibUntilMs = performance.now() + CALIB_WINDOW_MS;
      lastCalibG = null;
    }

    function updateFaceUpCalibration(event) {
      if (calibLocked) return;

      const g = event.accelerationIncludingGravity;
      if (!g || g.x == null || g.y == null || g.z == null) return;

      const gx = g.x || 0, gy = g.y || 0, gz = g.z || 0;
      const gmag = Math.sqrt(gx*gx + gy*gy + gz*gz);
      if (!isFinite(gmag) || gmag < GRAVITY_MIN_MAG) return;

      lastCalibG = { x: gx, y: gy, z: gz, mag: gmag };

      if (performance.now() > calibUntilMs) {
        if (calibSamples.length >= 1) lockCalibrationFromSamples();
        else finalizeCalibrationNow();
        return;
      }

      let still = false;
      if (event.acceleration && (event.acceleration.x != null || event.acceleration.y != null || event.acceleration.z != null)) {
        still = getAccelMag(event.acceleration) <= CALIB_STILL_ACCEL_MAX;
      }

      if (!updateFaceUpCalibration._prev) updateFaceUpCalibration._prev = { x: gx, y: gy, z: gz };
      const px = updateFaceUpCalibration._prev.x, py = updateFaceUpCalibration._prev.y, pz = updateFaceUpCalibration._prev.z;
      const dmag = Math.sqrt((gx-px)**2 + (gy-py)**2 + (gz-pz)**2);
      updateFaceUpCalibration._prev = { x: gx, y: gy, z: gz };

      if (!still) still = dmag <= CALIB_GRAV_DELTA_MAX;
      if (!still) return;

      const cosToZ = Math.abs(gz) / gmag;
      if (cosToZ < CALIB_NEAR_FLAT_COS) return;

      calibSamples.push(gz);
      if (calibSamples.length >= CALIB_MIN_SAMPLES) lockCalibrationFromSamples();
    }

    function lockCalibrationFromSamples() {
      const arr = calibSamples.slice().sort((a,b) => a-b);
      const mid = Math.floor(arr.length / 2);
      const medianGz = (arr.length % 2) ? arr[mid] : (arr[mid-1] + arr[mid]) / 2;

      const faceUpSign = (medianGz >= 0) ? +1 : -1;
      faceDownZSign = -faceUpSign;
      calibLocked = true;
    }

    function finalizeCalibrationNow() {
      if (calibLocked) return;

      if (calibSamples.length >= 1) {
        lockCalibrationFromSamples();
        return;
      }

      if (lastCalibG && isFinite(lastCalibG.mag) && lastCalibG.mag >= GRAVITY_MIN_MAG) {
        const cosToZ = Math.abs(lastCalibG.z) / lastCalibG.mag;
        if (cosToZ >= 0.55) {
          const faceUpSign = (lastCalibG.z >= 0) ? +1 : -1;
          faceDownZSign = -faceUpSign;
          calibLocked = true;
        }
      }
    }

    function computeCosToDownFromEvent(event) {
      if (!faceDownZSign) return null;
      const g = event.accelerationIncludingGravity;
      if (!g || g.x == null || g.y == null || g.z == null) return null;

      const gx = g.x || 0, gy = g.y || 0, gz = g.z || 0;

      const gzNorm = gz * faceDownZSign;
      const gmag = Math.sqrt(gx*gx + gy*gy + gzNorm*gzNorm);
      if (!isFinite(gmag) || gmag < GRAVITY_MIN_MAG) return null;

      if (Math.abs(gzNorm) < 0.55 * gmag) return null;

      return (gzNorm / gmag); // +1 = down, -1 = up
    }

    function updateFaceUpLatch(event, nowMs) {
      const cosToDown = computeCosToDownFromEvent(event);
      if (cosToDown == null) return;

      if (!faceUpState) {
        if (cosToDown <= FACEUP_ENTER_COS) {
          faceUpState = true;
          faceUpLatchedUntilMs = nowMs + FACEUP_LATCH_HOLD_MS;
        }
      } else {
        if (cosToDown <= FACEUP_EXIT_COS) {
          faceUpLatchedUntilMs = nowMs + FACEUP_LATCH_HOLD_MS;
        } else if (nowMs > faceUpLatchedUntilMs) {
          faceUpState = false;
        }
      }
    }

    function isFaceUpLatched(nowMs) {
      return faceUpState && nowMs <= faceUpLatchedUntilMs;
    }

    function checkFaceDownOnly(event) {
      if (activeRings.size === 0) {
        faceDownTriggeredThisRingWindow = false;
        return;
      }

      if (performance.now() - lastBellPlayMs < TURN_MUTE_LOCKOUT_MS) return;

      if (faceDownTriggeredThisRingWindow) return;
      if (!faceDownZSign) return;

      const cosToDown = computeCosToDownFromEvent(event);
      if (cosToDown == null) return;

      const maxTiltRad = (FACE_DOWN_MAX_TILT_DEG * Math.PI) / 180;
      const cosThreshold = Math.cos(maxTiltRad);

      if (cosToDown >= cosThreshold) {
        faceDownTriggeredThisRingWindow = true;
        applyAggressiveDampToActiveRings();
      }
    }

    function applyAggressiveDampToActiveRings() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;

      activeRings.forEach(r => {
        if (!r || r.ended) return;

        const aggressiveDecayTime = Math.min(0.25, (r.safeDuration || 0.25));

        try {
          if (typeof r.gain.gain.cancelAndHoldAtTime === "function") {
            r.gain.gain.cancelAndHoldAtTime(now);
          } else {
            r.gain.gain.cancelScheduledValues(now);
            r.gain.gain.setValueAtTime(r.gain.gain.value, now);
          }

          const current = Math.max(r.gain.gain.value, 0.0002);

          r.gain.gain.setValueAtTime(current, now);
          r.gain.gain.exponentialRampToValueAtTime(0.0001, now + aggressiveDecayTime);
          r.src.stop(now + aggressiveDecayTime + 0.01);
        } catch (e) {}
      });
    }

    // ---- ONE-TIME CALIBRATION LISTENER ----
    let calibrationListening = false;
    let calibrationCompleted = false;

    function calibrationMotionHandler(event) {
      if (calibrationCompleted) return;
      updateFaceUpCalibration(event);
      if (calibLocked) {
        calibrationCompleted = true;
        stopCalibrationListening();
      }
    }

    function startCalibrationListeningOnce() {
      if (calibrationListening || calibrationCompleted) return;
      calibrationListening = true;
      beginFaceUpCalibration();
      window.addEventListener("devicemotion", calibrationMotionHandler, { passive: true });
    }

    function stopCalibrationListening(finalize = false) {
      if (!calibrationListening) return;
      calibrationListening = false;
      window.removeEventListener("devicemotion", calibrationMotionHandler);

      if (finalize && !calibrationCompleted) {
        finalizeCalibrationNow();
        calibrationCompleted = true;
      }
    }

    // ---- Dual-bell state + calibration (forward vs opposite) ----
    let currentNote = null;
    let secondNote = null;

    let dualCalibrating = false;
    let dualCalibCount = 0;

    // normalized direction for "Away From You"
    let dualForwardVec = null;

    // Skip gating: user must click Info first
    let skipUnlocked = false;

    function resetDualMode() {
      secondNote = null;
      dualCalibrating = false;
      dualCalibCount = 0;
      dualForwardVec = null;
      skipUnlocked = false;

      calibToast.classList.remove("active");
      calibProgress.textContent = "0";
      calibSkipWrap.classList.remove("active");

      setSingleUI();
      refreshTopRightButtons();
    }

    function startDualCalibration() {
      dualCalibrating = true;
      dualCalibCount = 0;
      dualForwardVec = null;
      calibProgress.textContent = "0";

      skipUnlocked = false;
      calibSkipWrap.classList.remove("active");

      calibToast.classList.add("active");
    }

    function finishDualCalibration() {
      if (!dualForwardVec) dualForwardVec = { x: 1, y: 0, z: 0 };
      dualCalibrating = false;
      calibToast.classList.remove("active");
    }

    function skipDualCalibration() {
      dualForwardVec = { x: 1, y: 0, z: 0 };
      dualCalibrating = false;
      calibToast.classList.remove("active");
    }

    function setSingleUI() {
      paneRight.classList.add("hidden");
      playScreen.style.background = currentNote ? currentNote.color : "#111827";
    }

    function setDualUI() {
      paneRight.classList.remove("hidden");
      playScreen.style.background =
        `linear-gradient(90deg, ${currentNote.color} 0%, ${currentNote.color} 50%, ${secondNote.color} 50%, ${secondNote.color} 100%)`;
    }

    // ---- Add-bell mode uses the SAME note screen ----
    let noteSelectMode = "primary";

    function setNoteScreenTextForMode(mode) {
      if (mode === "secondary") {
        noteTitleEl.textContent = "Choose your note";
        noteSubEl.textContent = "Pick a second bell note. Your current note is disabled.";
        noteHelpEl.textContent = "Tap any other note to add it as the second bell.";
      } else {
        noteTitleEl.textContent = "Choose your note";
        noteSubEl.textContent = "Full chromatic C5–B7 (top note B7). Each note uses the bell color palette.";
        noteHelpEl.textContent = "Swing to ring. You’ll see your note and bell on the next screen.";
      }
    }

    function showNoteScreen(mode = "primary") {
      noteSelectMode = mode;
      setNoteScreenTextForMode(mode);

      motionScreen.style.display = "none";
      playScreen.classList.remove("active");
      noteScreen.style.display = "block";

      sustainWrapper.classList.remove("active");

      addModeBack.classList.toggle("active", mode === "secondary");

      topRightStack.classList.remove("active");
      refreshDisabledButtonsForMode();
    }

    function showPlayScreen() {
      noteScreen.style.display = "none";
      playScreen.classList.add("active");

      sustainWrapper.classList.add("active");

      topRightStack.classList.add("active");
      addModeBack.classList.remove("active");

      if (currentNote && secondNote) setDualUI();
      else if (currentNote) setSingleUI();

      refreshTopRightButtons();
    }

    function refreshTopRightButtons() {
      if (!currentNote) {
        addBellBtn.style.display = "none";
        change2ndBtn.style.display = "none";
        removeBellBtn.style.display = "none";
        return;
      }

      if (!secondNote) {
        addBellBtn.style.display = "inline-flex";
        change2ndBtn.style.display = "none";
        removeBellBtn.style.display = "none";
      } else {
        addBellBtn.style.display = "none";
        change2ndBtn.style.display = "inline-flex";
        removeBellBtn.style.display = "inline-flex";
      }
    }

    // ---- HAPTIC (best available on web) ----
    // NOTE: iOS Safari/PWA generally does NOT support vibration.
    function bigHapticBump() {
      try {
        if (navigator.vibrate) navigator.vibrate([35, 12, 55]);
      } catch (e) {}
    }

    // ---- Play bell sample ----
    async function playBellToRingEl(note, ringEl, intensity = 1, visualDir = null) {
      if (!note) return;

      // Biggest practical web haptic (Android). Also triggers on tap-to-ring.
      bigHapticBump();

      ensureAudioCtx();
      if (!audioCtx) return;

      if (audioCtx.state === "suspended") await audioCtx.resume();

      const buffer = await loadNoteBuffer(note);
      if (!buffer) return;

      const now = audioCtx.currentTime;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;

      const gain = audioCtx.createGain();
      src.connect(gain);
      gain.connect(audioCtx.destination);

      const safeDuration = Math.max(buffer.duration, 0.05);

      const peak = volumeMaxGain;
      gain.gain.setValueAtTime(peak, now);

      const ringRef = { src, gain, ended: false, safeDuration };
      activeRings.add(ringRef);
      faceDownTriggeredThisRingWindow = false;

      const cleanup = () => {
        ringRef.ended = true;
        activeRings.delete(ringRef);
        if (activeRings.size === 0) faceDownTriggeredThisRingWindow = false;
      };
      src.addEventListener("ended", cleanup);

      const dampingVal = parseInt(sustainSlider.value, 10);
      const { floor } = applyDampingEnvelope(gain, now, dampingVal, peak);

      const tailPad = 0.03;
      const endNudgeAt = Math.max(now, now + safeDuration - tailPad);
      try { gain.gain.setTargetAtTime(floor, endNudgeAt, 0.015); } catch (e) {}

      src.start(now);
      src.stop(now + safeDuration);

      lastBellPlayMs = performance.now();

      // visuals
      const t = Math.min(Math.max(intensity, 0), 1);
      const minOffset = 10;
      const maxOffset = 32;
      const offset = minOffset + (maxOffset - minOffset) * t;

      let dir = visualDir || (Math.random() < 0.5 ? "left" : "right");
      let transform;

      if (dir === "left") transform = `translate(${-offset}px, 0px) rotate(0deg)`;
      else if (dir === "right") transform = `translate(${offset}px, 0px) rotate(0deg)`;
      else if (dir === "up") transform = `translate(0px, ${-offset}px) rotate(0deg)`;
      else if (dir === "down") transform = `translate(0px, ${offset}px) rotate(0deg)`;
      else transform = `translate(0px, 0px) rotate(${(Math.random() < 0.5 ? -1 : 1) * offset}deg)`;

      if (ringEl) {
        ringEl.style.transform = transform;
        setTimeout(() => { ringEl.style.transform = "translate(0px, 0px) rotate(0deg)"; }, 180);
      }
    }

    // =========================================================================
    // ==================  NEW “BEST” STRIKE DETECTION LOGIC  ==================
    // =========================================================================
    //
    // Goals:
    // - NO rings from simply starting to accelerate from still.
    // - Consistent across wrist snaps and big arm swings.
    // - Uses directional motion (axis + velocity proxy), not magnitude-only.
    // - Uses time-based dt so sensor rate differences don’t break behavior.
    // - State machine: IDLE -> SWINGING -> ARMED -> COOLDOWN
    //
    // Also enforces:
    // - While dual calibration toast is active (dualCalibrating), bells cannot play.
    //   (we still count calibration strikes)
    //
    // -------------------------------------------------------------------------

    let lastRingTimeMs = 0;

    // Common “human” numbers:
    const COOLDOWN_MS = 180;        // how fast you can ring again
    const ARM_MS      = 100;        // must be swinging for ~100ms before eligible
    const IDLE_MS     = 140;        // how long quiet before returning to IDLE

    // Axis/velocity proxy tuning:
    const V_DAMP_TC_S = 0.25;       // velocity proxy decay time constant (seconds)
    const AXIS_SMOOTH = 0.18;       // axis smoothing (0..1), higher = more responsive

    // Base thresholds (units are roughly m/s^2 for accel, and "m/s" for velocity proxy)
    // These are then adapted to device/noise.
    const V_ENTER_BASE = 0.55;      // start considering a swing
    const V_ARM_BASE   = 0.95;      // must exceed to arm strike
    const A_STOP_BASE  = 3.2;       // opposite-accel needed for a strike
    const DROP_RATIO   = 0.55;      // strike if |v| drops below (ratio * peak) fast

    // Intensity mapping (feels good for both wrist + arm)
    const V_INT_MIN = 0.95;
    const V_INT_MAX = 2.30;

    // If linear accel is missing, we estimate it by subtracting low-passed gravity.
    const GRAV_LP_ALPHA = 0.92; // closer to 1 = smoother gravity estimate

    // Noise tracking (adaptive thresholds)
    let noiseEMA = 0.20; // estimate of typical accel magnitude when "idle"
    const NOISE_ALPHA = 0.93;

    // Strike detector state
    const STRIKE_STATE = { IDLE: 0, SWINGING: 1, ARMED: 2, COOLDOWN: 3 };
    let strikeState = STRIKE_STATE.IDLE;

    let axisU = { x: 1, y: 0, z: 0 }; // unit swing axis (updates in SWINGING/ARMED)
    let vProxy = 0;                   // signed “velocity proxy” along axis
    let vPeak = 0;                    // peak |vProxy| during current swing
    let armStartMs = null;            // when we first exceeded V_ARM
    let quietSinceMs = null;          // time since low motion
    let lastTimeMs = null;

    // for jerk/direction mapping (dual bell)
    let lastAx = null, lastAy = null, lastAz = null;

    // gravity estimate (for fallback)
    let gravEst = { x: 0, y: 0, z: 0 };
    let gravInited = false;

    function dot3(a, b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
    function mag3(v) { return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z); }
    function norm3(v) {
      const m = mag3(v);
      if (!isFinite(m) || m < 1e-6) return { x: 1, y: 0, z: 0, m: 0 };
      return { x: v.x/m, y: v.y/m, z: v.z/m, m };
    }
    function clamp(x, a, b) { return Math.min(Math.max(x, a), b); }

    function computeVisualDirFromJerk(jx, jy, jz) {
      const absX = Math.abs(jx), absY = Math.abs(jy), absZ = Math.abs(jz);
      const maxComp = Math.max(absX, absY, absZ);
      const MIN_J = 0.30;

      if (maxComp < MIN_J) return Math.random() < 0.5 ? "left" : "right";
      if (maxComp === absX) return jx > 0 ? "left" : "right";
      if (maxComp === absY) return jy > 0 ? "up" : "down";
      return jz > 0 ? "up" : "down";
    }

    // Adaptive thresholds based on current noise estimate.
    function thresholdsFromNoise() {
      // Convert accel noise into a conservative bump:
      // If device is noisy, raise thresholds modestly.
      const n = clamp(noiseEMA, 0.10, 0.90);

      // Accel stop threshold: ~3.2 base, up to ~4.4 on noisy sensors
      const aStop = A_STOP_BASE + (n - 0.20) * 2.0;

      // Velocity thresholds: raised slightly on noisy sensors
      const vEnter = V_ENTER_BASE + (n - 0.20) * 0.35;
      const vArm   = V_ARM_BASE   + (n - 0.20) * 0.55;

      return { aStop, vEnter, vArm };
    }

    function estimateLinearAccel(event) {
      // Prefer true linear accel
      const a = event.acceleration;
      if (a && (a.x != null || a.y != null || a.z != null)) {
        return { x: a.x || 0, y: a.y || 0, z: a.z || 0 };
      }

      // Fallback: subtract low-passed gravity from accelIncludingGravity
      const g = event.accelerationIncludingGravity;
      if (!g) return null;

      const gx = g.x || 0, gy = g.y || 0, gz = g.z || 0;

      if (!gravInited) {
        gravEst.x = gx; gravEst.y = gy; gravEst.z = gz;
        gravInited = true;
      } else {
        gravEst.x = GRAV_LP_ALPHA * gravEst.x + (1 - GRAV_LP_ALPHA) * gx;
        gravEst.y = GRAV_LP_ALPHA * gravEst.y + (1 - GRAV_LP_ALPHA) * gy;
        gravEst.z = GRAV_LP_ALPHA * gravEst.z + (1 - GRAV_LP_ALPHA) * gz;
      }

      return { x: gx - gravEst.x, y: gy - gravEst.y, z: gz - gravEst.z };
    }

    function updateAxisFromAccel(aVec) {
      // use direction of accel to estimate the dominant swing axis
      const n = norm3(aVec);
      if (n.m <= 0) return;

      // prevent axis flips: keep same hemisphere
      let cand = { x: n.x, y: n.y, z: n.z };
      if (dot3(cand, axisU) < 0) {
        cand.x *= -1; cand.y *= -1; cand.z *= -1;
      }

      // smooth
      axisU.x = (1 - AXIS_SMOOTH) * axisU.x + AXIS_SMOOTH * cand.x;
      axisU.y = (1 - AXIS_SMOOTH) * axisU.y + AXIS_SMOOTH * cand.y;
      axisU.z = (1 - AXIS_SMOOTH) * axisU.z + AXIS_SMOOTH * cand.z;

      const u = norm3(axisU);
      axisU = (u.m > 0) ? { x: u.x, y: u.y, z: u.z } : axisU;
    }

    function ringFromStrike(nowMs, intensity01, visualDir, dirVecForDual) {
      ensureWakeLock();

      const faceUpNow = isFaceUpLatched(nowMs);

      if (secondNote) {
        if (faceUpNow) {
          // face-up rings both ONLY when not calibrating
          if (!dualCalibrating) {
            playBellToRingEl(currentNote, bellRingLeft, intensity01, visualDir);
            playBellToRingEl(secondNote, bellRingRight, intensity01, visualDir);
          }
        } else {
          if (dualCalibrating) {
            // calibration: DO NOT PLAY bells, only count progress
            if (!dualForwardVec) {
              dualForwardVec = dirVecForDual;
              dualCalibCount = 1;
            } else {
              const s = dot3(dirVecForDual, dualForwardVec);
              if (s >= 0) dualCalibCount++;
              else {
                dualForwardVec = dirVecForDual;
                dualCalibCount = 1;
              }
            }

            calibProgress.textContent = String(dualCalibCount);

            if (dualCalibCount >= 3) {
              const nf = norm3(dualForwardVec);
              dualForwardVec = (nf.m > 0) ? { x: nf.x, y: nf.y, z: nf.z } : { x: 1, y: 0, z: 0 };
              finishDualCalibration();
            }
          } else {
            const f = dualForwardVec ? dualForwardVec : { x: 1, y: 0, z: 0 };
            const s = dot3(dirVecForDual, f);

            if (s >= 0) playBellToRingEl(currentNote, bellRingLeft, intensity01, visualDir);
            else playBellToRingEl(secondNote, bellRingRight, intensity01, visualDir);
          }
        }
      } else {
        // single bell always allowed
        playBellToRingEl(currentNote, bellRingLeft, intensity01, visualDir);
      }
    }

    function handleMotion(event) {
      if (!currentNote) return;

      const nowMs = performance.now();

      updateFaceUpLatch(event, nowMs);
      checkFaceDownOnly(event);

      const aLin = estimateLinearAccel(event);
      if (!aLin) return;

      // dt in seconds (rate-normalized)
      if (lastTimeMs == null) lastTimeMs = nowMs;
      let dt = (nowMs - lastTimeMs) / 1000;
      lastTimeMs = nowMs;
      dt = clamp(dt, 0.005, 0.050); // avoid huge spikes / tiny dt

      // jerk for visuals + dual direction mapping
      const ax = aLin.x, ay = aLin.y, az = aLin.z;

      if (lastAx == null) { lastAx = ax; lastAy = ay; lastAz = az; }

      const jx = ax - lastAx, jy = ay - lastAy, jz = az - lastAz;
      lastAx = ax; lastAy = ay; lastAz = az;

      // Update noise estimate when truly quiet-ish (helps adapt across devices)
      const aMag = Math.sqrt(ax*ax + ay*ay + az*az);
      if (strikeState === STRIKE_STATE.IDLE) {
        noiseEMA = NOISE_ALPHA * noiseEMA + (1 - NOISE_ALPHA) * aMag;
      } else if (strikeState === STRIKE_STATE.SWINGING && aMag < 0.9) {
        // small slow update even during swing if momentarily quiet
        noiseEMA = 0.98 * noiseEMA + 0.02 * aMag;
      }

      const { aStop, vEnter, vArm } = thresholdsFromNoise();

      // Update axis + project accel onto axis
      // In IDLE: keep axis stable, but allow gentle updates so it matches how you start holding.
      if (strikeState !== STRIKE_STATE.COOLDOWN) {
        if (aMag > 0.18) updateAxisFromAccel(aLin);
      }

      const aProj = ax*axisU.x + ay*axisU.y + az*axisU.z; // signed

      // Velocity proxy integration with damping (prevents drift and makes swings comparable)
      const damp = 1 - Math.exp(-dt / V_DAMP_TC_S);
      vProxy = (1 - damp) * vProxy + aProj * dt;

      const vAbs = Math.abs(vProxy);

      // Quiet detection (return to IDLE cleanly)
      if (vAbs < 0.20 && aMag < 0.35) {
        if (quietSinceMs == null) quietSinceMs = nowMs;
      } else {
        quietSinceMs = null;
      }

      // Cooldown handling
      if (strikeState === STRIKE_STATE.COOLDOWN) {
        if (nowMs - lastRingTimeMs >= COOLDOWN_MS) {
          // after cooldown, don’t instantly ring again; require swing rebuild
          strikeState = STRIKE_STATE.IDLE;
          vProxy = 0;
          vPeak = 0;
          armStartMs = null;
          quietSinceMs = null;
        }
        return;
      }

      // State transitions
      if (strikeState === STRIKE_STATE.IDLE) {
        vPeak = 0;
        armStartMs = null;

        // enter swing only if we have some sustained directional motion (vProxy-based)
        if (vAbs >= vEnter) {
          strikeState = STRIKE_STATE.SWINGING;
          vPeak = vAbs;
        }
        return;
      }

      if (strikeState === STRIKE_STATE.SWINGING) {
        vPeak = Math.max(vPeak, vAbs);

        // If it goes quiet for a while, reset
        if (quietSinceMs != null && (nowMs - quietSinceMs) >= IDLE_MS) {
          strikeState = STRIKE_STATE.IDLE;
          vProxy = 0;
          vPeak = 0;
          armStartMs = null;
          return;
        }

        // Arm only after exceeding vArm for ~ARM_MS (prevents “from still”)
        if (vAbs >= vArm) {
          if (armStartMs == null) armStartMs = nowMs;
          if ((nowMs - armStartMs) >= ARM_MS) {
            strikeState = STRIKE_STATE.ARMED;
          }
        } else {
          armStartMs = null;
        }

        return;
      }

      if (strikeState === STRIKE_STATE.ARMED) {
        vPeak = Math.max(vPeak, vAbs);

        // If it goes quiet for a while, reset (prevents stuck armed state)
        if (quietSinceMs != null && (nowMs - quietSinceMs) >= IDLE_MS) {
          strikeState = STRIKE_STATE.IDLE;
          vProxy = 0;
          vPeak = 0;
          armStartMs = null;
          return;
        }

        // STRIKE CONDITIONS (any of these):
        // 1) Strong opposite accel (aProj opposes vProxy) AND magnitude passes threshold
        const oppAccel = (vProxy !== 0) ? (Math.sign(aProj) === -Math.sign(vProxy)) : false;
        const hardStop = oppAccel && (Math.abs(aProj) >= aStop);

        // 2) Fast “energy drop”: vAbs drops below ratio of peak while accel is opposing
        const drop = (vPeak > 0.001) && (vAbs <= (DROP_RATIO * vPeak)) && oppAccel;

        // 3) True reversal near zero: vProxy crosses 0 while peak was significant
        //    (works for sharp snaps and clean direction changes)
        const reversal = (vPeak >= vArm) && (Math.abs(vProxy) < 0.08) && (Math.abs(aProj) >= (aStop * 0.75));

        const canRingByTime = (nowMs - lastRingTimeMs) >= COOLDOWN_MS;

        if (canRingByTime && (hardStop || drop || reversal)) {
          // Determine intensity from peak swing (vPeak)
          const vForInt = clamp(vPeak, V_INT_MIN, V_INT_MAX);
          const intensity = (vForInt - V_INT_MIN) / (V_INT_MAX - V_INT_MIN);

          const visualDir = computeVisualDirFromJerk(jx, jy, jz);

          // Direction vector for dual-bell selection:
          // Use opposite jerk direction (matches your prior mapping), normalized.
          const oppJerk = { x: -jx, y: -jy, z: -jz };
          const jN = norm3(oppJerk);

          // If jerk is weak/ambiguous, fall back to last calibration vector
          const JERK_DIR_MIN = 0.35;
          let dir;
          if (jN.m < JERK_DIR_MIN && dualForwardVec) {
            dir = dualForwardVec;
          } else if (jN.m > 0) {
            dir = { x: jN.x, y: jN.y, z: jN.z };
          } else {
            dir = dualForwardVec || { x: 1, y: 0, z: 0 };
          }

          // Enforce: during dual calibration toast, bells cannot play.
          // (ringFromStrike already blocks playing when dualCalibrating; it only counts)
          ringFromStrike(nowMs, intensity, visualDir, dir);

          // Enter cooldown and reset swing accumulators
          lastRingTimeMs = nowMs;
          strikeState = STRIKE_STATE.COOLDOWN;

          vProxy = 0;
          vPeak = 0;
          armStartMs = null;
          quietSinceMs = null;

          return;
        }

        // If we’re armed but speed falls too low without a clean stop, demote to SWINGING
        if (vAbs < vEnter) {
          strikeState = STRIKE_STATE.SWINGING;
          armStartMs = null;
        }

        return;
      }
    }

    function startMotionListening() {
      lastRingTimeMs = 0;

      strikeState = STRIKE_STATE.IDLE;
      axisU = { x: 1, y: 0, z: 0 };
      vProxy = 0;
      vPeak = 0;
      armStartMs = null;
      quietSinceMs = null;

      lastTimeMs = null;
      lastAx = lastAy = lastAz = null;

      gravInited = false;
      gravEst = { x: 0, y: 0, z: 0 };

      window.addEventListener("devicemotion", handleMotion);
    }

    function stopMotionListening() {
      window.removeEventListener("devicemotion", handleMotion);

      strikeState = STRIKE_STATE.IDLE;
      vProxy = 0;
      vPeak = 0;
      armStartMs = null;
      quietSinceMs = null;
      lastTimeMs = null;

      lastAx = lastAy = lastAz = null;
      gravInited = false;

      faceDownTriggeredThisRingWindow = false;
      activeRings.clear();
    }

    // ---- MOTION PERMISSION (iOS) ----
    async function requestMotionPermission() {
      try {
        if (typeof DeviceMotionEvent !== "undefined" &&
            typeof DeviceMotionEvent.requestPermission === "function") {
          const res = await DeviceMotionEvent.requestPermission();
          return res === "granted";
        }
        return true;
      } catch (err) {
        console.error("Motion permission error:", err);
        return false;
      }
    }

    // ---- UI FLOW ----
    startBtn.addEventListener("click", async () => {
      await resumeAudioCtx();
      const granted = await requestMotionPermission();
      if (!granted) {
        alert("Motion access hasn't been granted yet. Close this window and try again.");
        return;
      }

      startCalibrationListeningOnce();

      preloadAllNotesPromise = null;
      preloadAllNotes();

      motionScreen.style.display = "none";
      showNoteScreen("primary");
      showHeadphoneWarningOnce();
    });

    function pickPrimaryNote(note) {
      currentNote = note;
      resetDualMode();

      playNoteLeft.textContent = note.label;
      playScreen.style.background = note.color;

      showPlayScreen();
      stopMotionListening();
      startMotionListening();

      // tap-start preview
      playBellToRingEl(note, bellRingLeft, 1, null);
    }

    function pickSecondNote(note) {
      secondNote = note;
      playNoteRight.textContent = note.label;

      setDualUI();
      showPlayScreen();

      startDualCalibration();
      refreshTopRightButtons();
    }

    backBtn.addEventListener("click", () => {
      currentNote = null;
      resetDualMode();
      stopMotionListening();
      playScreen.classList.remove("active");
      showNoteScreen("primary");
    });

    addBellBtn.addEventListener("click", () => {
      if (!currentNote) return;
      showNoteScreen("secondary");
    });

    change2ndBtn.addEventListener("click", () => {
      if (!currentNote) return;
      showNoteScreen("secondary");
    });

    removeBellBtn.addEventListener("click", () => {
      resetDualMode();
      if (currentNote) {
        setSingleUI();
        showPlayScreen();
      }
    });

    addModeBack.addEventListener("click", () => {
      showPlayScreen();
    });

    // Calibration info / skip gating
    calibInfoBtn.addEventListener("click", () => {
      alert(
        "If you can’t swing your device, you can skip calibration.\n\n" +
        "Without calibration, the app will still work, but the two-bell direction mapping may be less consistent."
      );
      skipUnlocked = true;
      calibSkipWrap.classList.add("active");
    });

    calibSkipBtn.addEventListener("click", () => {
      if (!skipUnlocked) return;
      skipDualCalibration();
    });

    // Tap-to-ring
    // Enforce: bells cannot be played while dual calibration toast is up.
    playNoteLeft.addEventListener("click", () => {
      if (!currentNote) return;
      if (secondNote && dualCalibrating) return;
      playBellToRingEl(currentNote, bellRingLeft, 1, null);
    });
    bellVisualLeft.addEventListener("click", () => {
      if (!currentNote) return;
      if (secondNote && dualCalibrating) return;
      playBellToRingEl(currentNote, bellRingLeft, 1, null);
    });

    playNoteRight.addEventListener("click", () => {
      if (!secondNote) return;
      if (dualCalibrating) return;
      playBellToRingEl(secondNote, bellRingRight, 1, null);
    });
    bellVisualRight.addEventListener("click", () => {
      if (!secondNote) return;
      if (dualCalibrating) return;
      playBellToRingEl(secondNote, bellRingRight, 1, null);
    });

    function bindKeyActivate(el, fn) {
      el.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          fn();
        }
      });
    }
    bindKeyActivate(bellVisualLeft, () => {
      if (!currentNote) return;
      if (secondNote && dualCalibrating) return;
      playBellToRingEl(currentNote, bellRingLeft, 1, null);
    });
    bindKeyActivate(bellVisualRight, () => {
      if (!secondNote) return;
      if (dualCalibrating) return;
      playBellToRingEl(secondNote, bellRingRight, 1, null);
    });

    // Build note grid once; click behavior depends on mode
    function initNoteButtons() {
      NOTES.forEach((n) => {
        const btn = document.createElement("button");
        btn.className = "note-btn";
        btn.type = "button";
        btn.style.background = n.color;
        btn.textContent = n.label;

        preloadNoteOnIntent(btn, n);

        btn.addEventListener("click", async () => {
          await resumeAudioCtx();

          // finalize face-up calibration if user picks a note early
          if (!calibrationCompleted) stopCalibrationListening(true);

          if (noteSelectMode === "secondary") {
            if (!currentNote) return;
            if (n.id === currentNote.id) return;
            await loadNoteBuffer(n);
            pickSecondNote(n);
            return;
          }

          await loadNoteBuffer(n);
          pickPrimaryNote(n);
        });

        btn.dataset.noteId = n.id;
        noteGrid.appendChild(btn);
      });
    }
    initNoteButtons();

    function refreshDisabledButtonsForMode() {
      const buttons = noteGrid.querySelectorAll("button.note-btn");
      buttons.forEach((btn) => {
        btn.classList.remove("disabled");
        btn.disabled = false;

        if (noteSelectMode === "secondary" && currentNote && btn.dataset.noteId === currentNote.id) {
          btn.classList.add("disabled");
          btn.disabled = true;
        }
      });
    }

    window.addEventListener("load", () => {
      const needsExplicitPermission =
        typeof DeviceMotionEvent !== "undefined" &&
        typeof DeviceMotionEvent.requestPermission === "function";

      preloadAllNotes();

      if (!needsExplicitPermission) {
        motionScreen.style.display = "none";
        showNoteScreen("primary");
        showHeadphoneWarningOnce();
        startCalibrationListeningOnce();
      }
    });

    window.addEventListener("touchstart", () => { resumeAudioCtx(); }, { passive: true });

    document.addEventListener("visibilitychange", () => { if (!document.hidden) resetAudioContextOnReturn(); });
    window.addEventListener("pageshow", () => { resetAudioContextOnReturn(); });
    window.addEventListener("focus", () => { resetAudioContextOnReturn(); });
  </script>

  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("/sw.js")
          .catch(err => console.error("SW registration failed:", err));
      });
    }
  </script>
</body>
</html>
