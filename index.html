<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PocketChimes</title>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-3G2QH25N85"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-3G2H25N85');
  </script>

  <!-- PWA & theme color -->
  <meta name="theme-color" content="#111827" />

  <!-- Tab favicons (desktop/mobile) -->
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon_32_transparent.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon_16_transparent.png">

  <!-- Generic / legacy favicon hook -->
  <link rel="shortcut icon" href="/favicons/favicon_32_transparent.png" type="image/png">

  <!-- iOS home-screen icon -->
  <link rel="apple-touch-icon" href="https://pocketchimes.com/favicons/favicon_180_transparent.png">

  <!-- Web App Manifest -->
  <link rel="manifest" href="/favicons/site.webmanifest">

  <style>
    html, body {
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
      position: fixed;
      width: 100%;
      height: 100%;
    }

    :root {
      --bg: #111827;
      --text: #f9fafb;
      --card: #1f2937;
      --shadow-soft: 0 12px 30px rgba(0, 0, 0, 0.35);
      --radius-xl: 1.5rem;
      --radius-full: 999px;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;

      --ui-panel: rgba(248, 250, 252, 0.92);
      --ui-border: rgba(15, 23, 42, 0.25);
      --ui-shadow: 0 10px 22px rgba(15, 23, 42, 0.25);
      --ui-text: #0b1120;
      --ui-subtext: rgba(11, 17, 32, 0.72);
      --track: rgba(15, 23, 42, 0.25);
      --thumb: rgba(15, 23, 42, 0.95);
      --thumb-ring: rgba(15, 23, 42, 0.15);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font-main);
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      position: relative;
    }

    .global-logo {
      position: fixed;
      top: 1.1rem;
      left: 50%;
      transform: translateX(-50%);
      width: 96px;
      height: auto;
      z-index: 20;
      pointer-events: none;
    }

    .app {
      width: 100%;
      max-width: 480px;
      margin: auto;
      padding: 3rem 1.2rem 2.5rem;
    }

    .card, .note-card {
      background: radial-gradient(circle at top left, #1f2937 0, #020617 70%);
      border-radius: 1.75rem;
      border: 1px solid #020617;
      box-shadow: var(--shadow-soft);
      padding: 1.4rem 1.5rem 1.6rem;
      backdrop-filter: blur(16px);
      text-align: center;
    }

    .title {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      margin-bottom: 0.4rem;
    }

    .subtitle {
      font-size: 0.9rem;
      opacity: 0.82;
      line-height: 1.4;
      margin-bottom: 1.2rem;
    }

    .primary-btn {
      border-radius: var(--radius-full);
      border: none;
      padding: 0.7rem 1.1rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: #facc15;
      color: #1f2937;
      box-shadow: 0 10px 24px rgba(0,0,0,0.45);
    }

    .primary-btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 5px 12px rgba(0,0,0,0.55);
    }

    /* NOTE SELECTION SCREEN */
    .note-title {
      font-size: 1.15rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
    }

    .note-subtitle {
      font-size: 0.85rem;
      opacity: 0.8;
      margin-bottom: 0.7rem;
    }

    .note-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 0.65rem;
      margin-top: 0.4rem;
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 0.2rem;
    }

    .note-btn {
      border: none;
      border-radius: 1rem;
      padding: 0.6rem 0.3rem;
      font-weight: 700;
      font-size: 0.9rem;
      color: #0b1120;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
      transform: translateY(0);
      transition: transform 0.16s ease-out, box-shadow 0.16s ease-out, filter 0.16s ease-out;
      text-shadow: 0 1px 3px rgba(0,0,0,0.35);
    }

    .note-btn:active {
      transform: translateY(2px) scale(0.97);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.55);
      filter: brightness(0.95);
    }

    .note-help {
      margin-top: 0.8rem;
      font-size: 0.8rem;
      opacity: 0.82;
    }

    /* PLAY SCREEN */
    .play-screen {
      position: fixed;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: #020617;
      padding: 1.2rem;
    }
    .play-screen.active { display: flex; }

    .back-btn {
      position: fixed;
      top: 0.9rem;
      left: 0.9rem;
      border-radius: var(--radius-full);
      border: 1px solid rgba(15, 23, 42, 0.4);
      background: rgba(248, 250, 252, 0.92);
      padding: 0.35rem 0.85rem;
      font-size: 0.8rem;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.3);
      z-index: 40;
    }

    .back-btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 4px 8px rgba(15, 23, 42, 0.45);
    }

    .play-note-label {
      font-size: 3.4rem;
      font-weight: 800;
      letter-spacing: 0.06em;
      margin-bottom: 1.3rem;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
      cursor: pointer;
    }

    .bell-visual {
      position: relative;
      width: 150px;
      height: 150px;
      margin-bottom: 1rem;
      cursor: pointer;
    }

    .bell-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 8px solid rgba(15, 23, 42, 0.85);
      background: radial-gradient(circle at 30% 20%,
        rgba(248,250,252,0.96) 0,
        rgba(248,250,252,0.7) 40%,
        rgba(248,250,252,0.25) 100%);
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.45);
      transform-origin: 50% 15%;
      transform: translate(0px, 0px) rotate(0deg);
      transition: transform 0.09s ease-out;
    }

    .bell-clapper {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(15, 23, 42, 0.95);
      box-shadow: 0 5px 10px rgba(15,23,42,0.7);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .hint-text {
      font-size: 0.85rem;
      opacity: 0.9;
      max-width: 18rem;
      line-height: 1.5;
      margin-bottom: 0.8rem;
    }

    /* ---------- PRO SLIDER STYLING ---------- */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      outline: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(to bottom, rgba(255,255,255,0.7), rgba(255,255,255,0.25));
      box-shadow: inset 0 0 0 2px var(--track);
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--thumb);
      box-shadow: 0 10px 22px rgba(0,0,0,0.25), 0 0 0 10px var(--thumb-ring);
      margin-top: -8px; /* centers thumb on 12px track */
    }
    input[type="range"]:active::-webkit-slider-thumb {
      transform: scale(1.03);
    }

    input[type="range"]::-moz-range-track {
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(to bottom, rgba(255,255,255,0.7), rgba(255,255,255,0.25));
      box-shadow: inset 0 0 0 2px var(--track);
    }
    input[type="range"]::-moz-range-thumb {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--thumb);
      border: none;
      box-shadow: 0 10px 22px rgba(0,0,0,0.25), 0 0 0 10px var(--thumb-ring);
    }

    /* Sustain slider panel (bottom center) */
    .sustain-wrapper {
      width: min(340px, 92vw);
      margin-top: 0.55rem;
      padding: 0.9rem 1rem 1rem;
      border-radius: 1.1rem;
      background: var(--ui-panel);
      border: 1px solid var(--ui-border);
      box-shadow: var(--ui-shadow);
      color: var(--ui-text);
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      z-index: 35;
    }

    .sustain-label-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.75rem;
    }

    .sustain-label {
      font-size: 0.92rem;
      font-weight: 800;
      letter-spacing: 0.01em;
    }

    .sustain-sub {
      font-size: 0.78rem;
      color: var(--ui-subtext);
      margin-top: 0.15rem;
      text-align: left;
    }

    .sustain-value {
      font-size: 0.95rem;
      font-weight: 900;
      min-width: 2.3rem;
      text-align: right;
    }

    .sustain-slider {
      width: 100%;
      height: 38px; /* more touch-friendly */
    }

    /* Gain (left, vertical, big + clean) */
    .gain-wrapper {
      position: fixed;
      left: 0.8rem;
      top: 50%;
      transform: translateY(-50%);
      z-index: 50;
      width: 88px;
      padding: 0.85rem 0.7rem 0.95rem;
      border-radius: 1.2rem;
      background: var(--ui-panel);
      border: 1px solid var(--ui-border);
      box-shadow: var(--ui-shadow);
      display: none;
      color: var(--ui-text);
      align-items: center;
      gap: 0.55rem;
    }
    .gain-wrapper.active {
      display: flex;
      flex-direction: column;
    }

    .gain-title {
      font-size: 0.92rem;
      font-weight: 900;
      letter-spacing: 0.01em;
      line-height: 1.1;
    }

    .gain-hint {
      font-size: 0.72rem;
      color: var(--ui-subtext);
      line-height: 1.15;
      text-align: center;
      margin-top: -0.2rem;
    }

    .gain-value {
      font-size: 1.05rem;
      font-weight: 950;
      margin-top: 0.1rem;
    }

    .gain-slider {
      /* We'll draw it by rotating a normal horizontal slider for consistent styling */
      width: 220px;   /* becomes height after rotation */
      height: 38px;
      transform: rotate(-90deg);
      touch-action: none;
      margin: 0.35rem 0;
    }

    @media (max-width: 400px) {
      .card, .note-card { padding: 1.2rem 1.2rem 1.3rem; }
      .note-btn { padding: 0.55rem 0.25rem; }
      .gain-wrapper { width: 82px; left: 0.55rem; }
      .gain-slider { width: 200px; }
      .sustain-wrapper { width: min(330px, 92vw); }
    }
  </style>
</head>

<body>
  <img
    class="global-logo"
    src="/favicons/favicon_512_transparent.png"
    alt="PocketChimes bell logo"
  />

  <!-- MOTION PERMISSION SCREEN -->
  <div class="app" id="motion-screen" role="main">
    <div class="card">
      <div class="title">PocketChimes</div>
      <p class="subtitle">
        This app uses your phone’s motion sensors so you can swing it like a handbell.
        On iPhone, you’ll be asked to allow motion access.
      </p>
      <button class="primary-btn" id="start-btn" type="button">
        Enable motion & start
      </button>
    </div>
  </div>

  <!-- NOTE SELECTION SCREEN -->
  <div class="app" id="note-screen" style="display:none;" role="main">
    <div class="note-card">
      <div class="note-title">Choose your note</div>
      <div class="note-subtitle">
        Full chromatic C5–B7 (top note B7). Each note uses the bell color palette.
      </div>

      <div class="note-grid" id="note-grid">
        <!-- Note buttons injected by JS -->
      </div>

      <div class="note-help">
        Swing to ring. You’ll see your note and bell on the next screen.
      </div>
    </div>
  </div>

  <!-- LEFT GAIN CONTROL (vertical) -->
  <div class="gain-wrapper" id="gain-wrapper" aria-label="Gain control">
    <div class="gain-title">Gain</div>
    <div class="gain-hint">Higher can<br>distort</div>
    <div class="gain-value" id="gain-value-label">1</div>
    <input
      type="range"
      id="gain-slider"
      class="gain-slider"
      min="1"
      max="10"
      step="1"
      value="1"
      aria-label="Gain slider"
    />
  </div>

  <!-- PLAY SCREEN -->
  <div class="play-screen" id="play-screen" role="main">
    <button class="back-btn" id="back-btn" type="button">
      ← Notes
    </button>

    <div class="play-note-label" id="play-note-label">
      C5
    </div>

    <div
      class="bell-visual"
      id="bell-visual"
      role="button"
      aria-label="Tap to ring the bell"
      tabindex="0"
    >
      <div class="bell-ring" id="bell-ring"></div>
      <div class="bell-clapper"></div>
    </div>

    <div class="hint-text">
      Swing your phone like a handbell.
      Tap the note or bell if needed.
    </div>

    <!-- SUSTAIN (bottom center) -->
    <div class="sustain-wrapper" id="sustain-wrapper">
      <div class="sustain-label-row">
        <div style="display:flex;flex-direction:column;align-items:flex-start;gap:0.1rem;">
          <div class="sustain-label">Sustain</div>
          <div class="sustain-sub">10 = full ring · 1 = damped</div>
        </div>
        <div class="sustain-value" id="sustain-value-label">10</div>
      </div>
      <input
        type="range"
        id="sustain-slider"
        class="sustain-slider"
        min="1"
        max="10"
        step="1"
        value="10"
        aria-label="Sustain slider"
      />
    </div>
  </div>

  <script>
    // ----- SCREEN WAKE LOCK: keep device awake while bell is ringing (motion only) -----
    // Best-effort only: many browsers (especially iOS Safari) ignore this.
    let wakeLock = null;
    const wakeLockSupported = "wakeLock" in navigator;

    async function requestWakeLock() {
      if (!wakeLockSupported) return;
      try {
        wakeLock = await navigator.wakeLock.request("screen");
        console.log("Wake lock is active");
        wakeLock.addEventListener("release", () => {
          console.log("Wake lock was released");
          wakeLock = null;
        });
      } catch (err) {
        console.warn("Wake lock error:", err.name, err.message);
      }
    }

    // Called only for motion-triggered rings (not taps)
    function ensureWakeLock() {
      if (!wakeLockSupported) return;
      if (!wakeLock) requestWakeLock();
    }

    // ----- NOTE DEFINITIONS: chromatic C5–B7 -----
    const PITCHES = [
      { name: "C",  color: "#FF3B30" },
      { name: "C#", color: "#FF2D92" },
      { name: "D",  color: "#FF9500" },
      { name: "D#", color: "#FFB300" },
      { name: "E",  color: "#FFEB3B" },
      { name: "F",  color: "#34C759" },
      { name: "F#", color: "#00FF7F" },
      { name: "G",  color: "#00C7BE" },
      { name: "G#", color: "#00B0FF" },
      { name: "A",  color: "#007AFF" },
      { name: "A#", color: "#AF52DE" },
      { name: "B",  color: "#5856D6" }
    ];

    const OCTAVES = [5, 6, 7];
    const NOTES = [];

    OCTAVES.forEach((oct) => {
      PITCHES.forEach((p) => {
        const id = `${p.name}${oct}`;
        const fileName = `${p.name}${oct}.wav`;
        const encodedFile = encodeURIComponent(fileName);

        let label;
        if (oct === 5) label = `${p.name} (Low)`;
        else if (oct === 6) label = p.name;
        else label = `${p.name} (High)`;

        NOTES.push({
          id,
          label,
          file: `audio/${encodedFile}`,
          color: p.color,
        });
      });
    });

    // ---- DOM ELEMENTS ----
    const motionScreen  = document.getElementById("motion-screen");
    const noteScreen    = document.getElementById("note-screen");
    const playScreen    = document.getElementById("play-screen");

    const startBtn      = document.getElementById("start-btn");
    const noteGrid      = document.getElementById("note-grid");
    const backBtn       = document.getElementById("back-btn");
    const playNoteLabel = document.getElementById("play-note-label");
    const bellRing      = document.getElementById("bell-ring");
    const bellVisual    = document.getElementById("bell-visual");

    // Gain (left)
    const gainWrapper    = document.getElementById("gain-wrapper");
    const gainSlider     = document.getElementById("gain-slider");
    const gainValueLabel = document.getElementById("gain-value-label");

    // Sustain (bottom)
    const sustainSlider     = document.getElementById("sustain-slider");
    const sustainValueLabel = document.getElementById("sustain-value-label");

    // ---- AUDIO (sample based) ----
    let audioCtx = null;
    let volumeMaxGain = 1.0; // "Gain"
    const noteBuffers = new Map();

    let preloadAllNotesPromise = null;

    function ensureAudioCtx() {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;
      if (!audioCtx || audioCtx.state === "closed") audioCtx = new AudioCtx();
    }

    async function resumeAudioCtx() {
      ensureAudioCtx();
      if (!audioCtx) return;
      if (audioCtx.state === "suspended") {
        try { await audioCtx.resume(); } catch (e) { console.warn("Audio resume error", e); }
      }
    }

    function resetAudioContextOnReturn() {
      if (audioCtx && audioCtx.state !== "closed") audioCtx.close().catch(() => {});
      audioCtx = null;
    }

    async function loadNoteBuffer(note) {
      if (noteBuffers.has(note.id)) return noteBuffers.get(note.id);
      ensureAudioCtx();
      if (!audioCtx) return null;

      const resp = await fetch(note.file);
      const arr  = await resp.arrayBuffer();
      const buf  = await audioCtx.decodeAudioData(arr);
      noteBuffers.set(note.id, buf);
      return buf;
    }

    function preloadAllNotes() {
      if (preloadAllNotesPromise) return preloadAllNotesPromise;

      preloadAllNotesPromise = Promise.all(
        NOTES.map(n =>
          loadNoteBuffer(n).catch(err => {
            console.warn("Failed to preload note", n.id, err);
            return null;
          })
        )
      ).then(() => {
        console.log("All notes preloaded");
      });

      return preloadAllNotesPromise;
    }

    // Headphone warning
    let headphoneWarningShown = false;
    function showHeadphoneWarningOnce() {
      if (headphoneWarningShown) return;
      headphoneWarningShown = true;
      alert(
        "Important: Please DO NOT use headphones when using this app — the bells can be EXTREMELY loud!\n" +
        "You're probably thinking to yourself, \"Oh it can't be *that* loud, can it?\"\n" +
        "Yes it can.\n\n" +
        "Also make sure your ringer isn't muted."
      );
    }

    // ---- GAIN slider ----
    gainValueLabel.textContent = gainSlider.value;
    gainSlider.addEventListener("input", () => {
      volumeMaxGain = parseFloat(gainSlider.value);
      gainValueLabel.textContent = gainSlider.value;
    });

    // ---- SUSTAIN slider ----
    sustainValueLabel.textContent = sustainSlider.value;
    sustainSlider.addEventListener("input", () => {
      sustainValueLabel.textContent = sustainSlider.value;
    });

    // ---- FACE DOWN DETECTION ----
    // We infer "face down" from accelerationIncludingGravity.z being strongly positive.
    let isFaceDown = false;
    const FACE_DOWN_Z_THRESHOLD = 7.0;

    // Track active rings so we can aggressively damp them mid-ring.
    const activeRings = new Set();

    function updateFaceDownFromEvent(event) {
      const accG = event.accelerationIncludingGravity;
      if (!accG || accG.z === null) return;

      const z = accG.z || 0;
      const nextFaceDown = z > FACE_DOWN_Z_THRESHOLD;

      // Trigger damping only on transition into face-down
      if (!isFaceDown && nextFaceDown) {
        isFaceDown = true;
        applyAggressiveDampToActiveRings();
      } else if (isFaceDown && !nextFaceDown) {
        isFaceDown = false;
      }
    }

    // --- Sustain curve helper (VERY LOW damping for most of the range; 1 is still very aggressive) ---
    function computeDecayTimeSeconds(sustainVal, safeDuration) {
      const s = Math.max(1, Math.min(10, sustainVal));
      const base = (s - 1) / 9; // 0..1

      // Flatten the top massively so 2–9 stay closer to full ring.
      // Increase k for even less damping overall; decrease for more midrange control.
      const k = 8;
      const t = 1 - Math.pow(1 - base, k); // 0..1, biased toward 1 for mid/high values

      const minDecay = Math.min(0.18, safeDuration); // sustain=1/10 (very damped)
      const maxDecay = safeDuration;                 // near full

      const ratio = maxDecay / Math.max(minDecay, 0.001);
      return minDecay * Math.pow(ratio, t);
    }

    // --- Face-down damping (tuned to match Sustain = 1/10 exactly) ---
    function applyAggressiveDampToActiveRings() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;

      // Must match the sustain=1/10 extreme (minDecay)
      const aggressiveDecayTime = 0.18;
      const holdTime = Math.min(0.02, aggressiveDecayTime * 0.25);

      activeRings.forEach(r => {
        if (!r || r.ended) return;

        try {
          if (typeof r.gain.gain.cancelAndHoldAtTime === "function") {
            r.gain.gain.cancelAndHoldAtTime(now);
          } else {
            r.gain.gain.cancelScheduledValues(now);
            r.gain.gain.setValueAtTime(r.gain.gain.value, now);
          }

          const current = Math.max(r.gain.gain.value, 0.0002);
          r.gain.gain.setValueAtTime(current, now);
          r.gain.gain.setValueAtTime(current, now + holdTime);
          r.gain.gain.exponentialRampToValueAtTime(0.0001, now + aggressiveDecayTime);

          r.src.stop(now + aggressiveDecayTime + 0.01);
        } catch (e) {
          // ignore if already stopped
        }
      });
    }

    // ---- Play bell sample ----
    async function playBell(note, intensity = 1, visualDir = null) {
      if (!note) return;

      ensureAudioCtx();
      if (!audioCtx) return;

      if (audioCtx.state === "suspended") {
        await audioCtx.resume();
      }

      const buffer = await loadNoteBuffer(note);
      if (!buffer) return;

      const now = audioCtx.currentTime;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;

      const gain = audioCtx.createGain();
      src.connect(gain);
      gain.connect(audioCtx.destination);

      const safeDuration = Math.max(buffer.duration, 0.05);

      // Start at current gain
      gain.gain.setValueAtTime(volumeMaxGain, now);

      // Register ring so face-down can damp it mid-flight
      const ringRef = { src, gain, ended: false };
      activeRings.add(ringRef);

      const cleanup = () => {
        ringRef.ended = true;
        activeRings.delete(ringRef);
      };
      src.addEventListener("ended", cleanup);

      const sustainVal = parseInt(sustainSlider.value, 10);

      if (sustainVal >= 10) {
        // Full sustain: unchanged behavior
        const fadeOutTime = 0.02;
        const fadeStart = now + safeDuration - fadeOutTime;

        gain.gain.setValueAtTime(volumeMaxGain, fadeStart);
        gain.gain.linearRampToValueAtTime(0.0001, now + safeDuration);

        src.start(now);
        src.stop(now + safeDuration);
      } else {
        // New, very gentle damping curve (log-perceived via exponential ramp)
        const decayTime = computeDecayTimeSeconds(sustainVal, safeDuration);

        // Preserve initial transient, then exponential fade
        const holdTime = Math.min(0.02, decayTime * 0.25);
        const fadeStart = now + holdTime;
        const endTime = now + decayTime;

        gain.gain.setValueAtTime(volumeMaxGain, now);
        gain.gain.setValueAtTime(volumeMaxGain, fadeStart);
        gain.gain.exponentialRampToValueAtTime(0.0001, endTime);

        src.start(now);
        src.stop(endTime + 0.01);
      }

      // If already face-down at ring start, damp immediately (same as sustain=1/10)
      if (isFaceDown) {
        applyAggressiveDampToActiveRings();
      }

      // --- visual wiggle (unchanged) ---
      const tVis = Math.min(Math.max(intensity, 0), 1);
      const minOffset = 10;
      const maxOffset = 32;
      const offset = minOffset + (maxOffset - minOffset) * tVis;

      let dir = visualDir || (Math.random() < 0.5 ? "left" : "right");
      let transform;

      if (dir === "left") {
        transform = `translate(${-offset}px, 0px) rotate(0deg)`;
      } else if (dir === "right") {
        transform = `translate(${offset}px, 0px) rotate(0deg)`;
      } else if (dir === "up") {
        transform = `translate(0px, ${-offset}px) rotate(0deg)`;
      } else if (dir === "down") {
        transform = `translate(0px, ${offset}px) rotate(0deg)`;
      } else {
        transform = `translate(0px, 0px) rotate(${(Math.random() < 0.5 ? -1 : 1) * offset}deg)`;
      }

      bellRing.style.transform = transform;
      setTimeout(() => {
        bellRing.style.transform = "translate(0px, 0px) rotate(0deg)";
      }, 180);
    }

    // ---- MOTION HANDLING ----
    let currentNote = null;
    let lastRingTime = 0;

    const MIN_INTERVAL   = 200;
    const DELTA_RING_MIN = 3.0;
    const DELTA_RING_MAX = 10.0;
    const RESET_DELTA    = 1.5;

    let inSwing = false;
    let lastMagnitude = null;
    let lastDelta = 0;
    let lastAx = null, lastAy = null, lastAz = null;

    function computeVisualDirFromJerk(jx, jy, jz) {
      const absX = Math.abs(jx);
      const absY = Math.abs(jy);
      const absZ = Math.abs(jz);
      const maxComp = Math.max(absX, absY, absZ);
      const MIN_JERK = 0.3;

      if (maxComp < MIN_JERK) return Math.random() < 0.5 ? "left" : "right";

      if (maxComp === absX) return jx > 0 ? "left" : "right";
      if (maxComp === absY) return jy > 0 ? "up" : "down";
      return jz > 0 ? "up" : "down";
    }

    function handleMotion(event) {
      if (!currentNote) return;

      // Update face-down continuously
      updateFaceDownFromEvent(event);

      let acc = event.acceleration;
      if (!acc || (acc.x === null && acc.y === null && acc.z === null)) {
        acc = event.accelerationIncludingGravity;
      }
      if (!acc) return;

      const ax = acc.x || 0;
      const ay = acc.y || 0;
      const az = acc.z || 0;

      const magnitude = Math.sqrt(ax*ax + ay*ay + az*az);

      if (lastMagnitude === null || lastAx === null) {
        lastMagnitude = magnitude;
        lastAx = ax; lastAy = ay; lastAz = az;
        return;
      }

      const jx = ax - lastAx;
      const jy = ay - lastAy;
      const jz = az - lastAz;

      const signedDelta = magnitude - lastMagnitude;
      const absDelta    = Math.abs(signedDelta);
      const now         = performance.now();

      if (absDelta < RESET_DELTA) inSwing = false;

      const prevSign = Math.sign(lastDelta);
      const currSign = Math.sign(signedDelta);
      const wasBuilding = Math.abs(lastDelta) > DELTA_RING_MIN;
      const changedDirection = prevSign !== 0 && currSign !== 0 && currSign === -prevSign;
      const justReversed = wasBuilding && changedDirection;

      if (!inSwing && justReversed && now - lastRingTime > MIN_INTERVAL) {
        const peak = Math.abs(lastDelta);

        if (peak >= DELTA_RING_MIN) {
          inSwing = true;
          lastRingTime = now;

          const clamped = Math.min(Math.max(peak, DELTA_RING_MIN), DELTA_RING_MAX);
          const intensity = (clamped - DELTA_RING_MIN) / (DELTA_RING_MAX - DELTA_RING_MIN);

          const visualDir = computeVisualDirFromJerk(jx, jy, jz);

          ensureWakeLock();
          playBell(currentNote, intensity, visualDir);
        }
      }

      lastMagnitude = magnitude;
      lastDelta     = signedDelta;
      lastAx = ax; lastAy = ay; lastAz = az;
    }

    function startMotionListening() {
      lastMagnitude = null;
      lastDelta = 0;
      lastAx = lastAy = lastAz = null;
      inSwing = false;
      window.addEventListener("devicemotion", handleMotion);
    }

    function stopMotionListening() {
      window.removeEventListener("devicemotion", handleMotion);
      lastMagnitude = null;
      lastDelta = 0;
      lastAx = lastAy = lastAz = null;
      inSwing = false;
      isFaceDown = false;
      activeRings.clear();
    }

    // ---- MOTION PERMISSION (iOS) ----
    async function requestMotionPermission() {
      try {
        if (
          typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function"
        ) {
          const res = await DeviceMotionEvent.requestPermission();
          return res === "granted";
        } else {
          return true;
        }
      } catch (err) {
        console.error("Motion permission error:", err);
        return false;
      }
    }

    // ---- UI FLOW ----
    startBtn.addEventListener("click", async () => {
      await resumeAudioCtx();
      const granted = await requestMotionPermission();

      if (!granted) {
        alert("Motion access hasn't been granted yet. Close this window and try again.");
        return;
      }

      preloadAllNotes();

      motionScreen.style.display = "none";
      noteScreen.style.display   = "block";
      showHeadphoneWarningOnce();
    });

    function showPlayScreen(note) {
      currentNote = note;
      playNoteLabel.textContent = note.label;
      playScreen.style.background = note.color;
      noteScreen.style.display = "none";
      playScreen.classList.add("active");

      gainWrapper.classList.add("active");
      startMotionListening();
    }

    function showNoteScreen() {
      currentNote = null;
      stopMotionListening();
      playScreen.classList.remove("active");
      noteScreen.style.display = "block";

      gainWrapper.classList.remove("active");
    }

    backBtn.addEventListener("click", showNoteScreen);

    playNoteLabel.addEventListener("click", () => {
      if (currentNote) playBell(currentNote, 1, null);
    });

    bellVisual.addEventListener("click", () => {
      if (currentNote) playBell(currentNote, 1, null);
    });

    bellVisual.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        if (currentNote) playBell(currentNote, 1, null);
      }
    });

    function initNoteButtons() {
      NOTES.forEach((n) => {
        const btn = document.createElement("button");
        btn.className = "note-btn";
        btn.type = "button";
        btn.style.background = n.color;
        btn.textContent = n.label;

        btn.addEventListener("click", async () => {
          await resumeAudioCtx();
          await loadNoteBuffer(n);
          showPlayScreen(n);
          playBell(n, 1, null);
        });

        noteGrid.appendChild(btn);
      });
    }

    initNoteButtons();

    window.addEventListener("load", () => {
      const needsExplicitPermission =
        typeof DeviceMotionEvent !== "undefined" &&
        typeof DeviceMotionEvent.requestPermission === "function";

      preloadAllNotes();

      if (!needsExplicitPermission) {
        motionScreen.style.display = "none";
        noteScreen.style.display   = "block";
        showHeadphoneWarningOnce();
      }
    });

    window.addEventListener("touchstart", () => { resumeAudioCtx(); }, { passive: true });

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) resetAudioContextOnReturn();
    });

    window.addEventListener("pageshow", () => { resetAudioContextOnReturn(); });
    window.addEventListener("focus", () => { resetAudioContextOnReturn(); });
  </script>

  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("/sw.js")
          .catch(err => console.error("SW registration failed:", err));
      });
    }
  </script>
</body>
</html>
